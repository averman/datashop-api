# datashop-api

A serverless backend for DataShop, a platform for managing, connecting, and processing data through a graph-based system of Data Entries and Control Nodes. Built using AWS Lambda, API Gateway, and DynamoDB.

## Table of Contents

-   [Overview](#overview)
-   [What is DataShop?](#what-is-datashop)
    -   [Core Concepts](#core-concepts)
    -   [Control Nodes](#control-nodes)
-   [Features](#features)
-   [Technology Stack](#technology-stack)
-   [Architecture (Conceptual)](#architecture-conceptual)
-   [Getting Started](#getting-started)
    -   [Prerequisites](#prerequisites)
    * [Installation & Deployment](#installation--deployment)
-   [Configuration](#configuration)
-   [Usage / API Endpoints](#usage--api-endpoints)
-   [Contributing](#contributing)
-   [License](#license)

## Overview

`datashop-api` provides the core backend services for the DataShop application. DataShop allows users to represent data and processing logic as a directed graph. This API leverages a serverless architecture (AWS Lambda, API Gateway, DynamoDB) to manage the nodes (Data Entries, Control Nodes) and edges (relationships) within these graphs, execute processing logic, and serve the resulting outputs.

## What is DataShop?

DataShop moves beyond simple file storage. It's a system for organizing discrete pieces of data and defining how they should be processed and combined through a visual or programmatic graph interface. Imagine a canvas where you place your data and the operations you want to perform on it.

### Core Concepts

1.  **Nodes:** The fundamental building blocks of a DataShop graph. There are two primary types:
    * **Data Entry Nodes:** Represent individual pieces of data. This could be raw text, structured data (like JSON), references to files in cloud storage (like S3 URIs), database records, etc. They are the raw inputs or intermediate data containers in the graph.
    * **Control Nodes:** Represent processing logic or operations. They take input from one or more connected nodes (Data Entries or other Control Nodes), perform an action, and produce an output.
2.  **Edges:** Directed connections between nodes, representing the flow of data or control. An edge from Node A to Node B indicates that Node A provides input to, is processed by, or is related to Node B. Edges have a `type` to define the nature of the relationship (e.g., `input`, `version_of`, `selected_by`).
3.  **Graphs (Projects):** Nodes and Edges are typically organized within a larger context, often referred to as a "Project" or "Graph". This provides isolation and organization.
4.  **Outputs:** The result of processing, typically generated by one or more specific Control Nodes designated as output nodes for the graph.

### Control Nodes

Control Nodes are the engines of DataShop, enabling complex data manipulation without requiring users to write extensive custom code for common operations. Examples include:

* **Selector Node:** Chooses specific input node(s) based on rules (e.g., latest version, specific metadata, specific label relationship). The "official" or "latest" examples from the previous description would now be implemented using Selector nodes.
* **Concatenator Node:** Combines the data from multiple input nodes into a single output (e.g., concatenating text, merging JSON objects, creating an XML structure).
* **Diff Node:** Compares data from two input nodes and outputs the differences.
* **Label Node:** Could act as a target for edges, allowing Data Entries or Control Nodes to be "tagged" or associated with a specific label concept via an edge.
* **Custom Logic Node:** (Potentially) Allows integration with custom processing logic (e.g., a specific Lambda function, an external API call).

Users interact with a dashboard (frontend) to construct these graphs visually, and the `datashop-api` handles the persistence, relationship management, and execution requests.

## Features

* Manages creation, retrieval, updating, and deletion (CRUD) of Nodes (Data Entries and Control Nodes).
* Manages CRUD operations for Edges, defining relationships and data flow between nodes.
* Stores metadata associated with Nodes and Edges in DynamoDB.
* Provides API endpoints for graph manipulation triggered by the frontend dashboard.
* Executes the logic defined by Control Nodes upon request.
* Serves the final processed output generated by designated output Control Nodes.
* Built on a scalable, serverless architecture.

## Technology Stack

* **Compute:** AWS Lambda
* **API Layer:** AWS API Gateway
* **Database:** AWS DynamoDB (for graph structure: nodes, edges, metadata)
* **Language/Runtime:** Node.js (18.x or later assumed)
* **Framework:** Serverless Framework
* **Cloud Provider:** Amazon Web Services (AWS)
* **Package Manager:** npm
* **(Note:** Data Entry nodes might store actual data payloads directly in DynamoDB for small items, or store references (e.g., S3 URIs) for larger blobs.)

## Architecture (Conceptual)

DataShop operates on a graph model persisted primarily in DynamoDB.

1.  Users interact with the Frontend UI (Dashboard) to build graphs.
2.  Frontend calls `datashop-api` (API Gateway) to manage Nodes and Edges.
3.  API Gateway routes requests to Lambda functions.
4.  Lambda functions perform CRUD operations on Nodes and Edges stored in DynamoDB.
5.  When an output is requested for a specific Control Node, the relevant Lambda function traverses the graph (following Edges), retrieves necessary data (from Data Entries or other Control Nodes), executes the Control Node's logic, and returns the result.
6.  Responses are sent back through API Gateway to the Frontend.

## Getting Started

### Prerequisites

* **AWS Account:** Required for deploying resources.
* **AWS CLI:** Configured with credentials (`aws configure`). [Link to AWS CLI setup](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html)
* **Node.js:** Version 18.x or later. [Download Node.js](https://nodejs.org/)
* **npm:** Included with Node.js.
* **Serverless Framework:** `npm install -g serverless` [Link to Serverless Framework setup](https://www.serverless.com/framework/docs/getting-started)

### Installation & Deployment

1.  **Clone the repository:**
    ```bash
    git clone [YOUR_REPOSITORY_URL]
    cd datashop-api
    ```
2.  **Install dependencies:**
    ```bash
    npm install
    ```
3.  **Configure Environment:**
    * Review `serverless.yml` for resource definitions (Lambda functions, DynamoDB tables for Nodes/Edges, IAM roles).
    * Use `.env` files or Serverless Framework profiles for stage-specific settings and secrets. Ensure `.env` is in `.gitignore`.
4.  **Deploy the service:**
    ```bash
    serverless deploy --stage [your-stage-name] --region [your-aws-region]
    ```
    * Replace `[your-stage-name]` and `[your-aws-region]`. This provisions the AWS resources.

## Configuration

Configuration (IAM roles, function settings, DynamoDB table definitions, API endpoints) is primarily managed via `serverless.yml`. Structure your DynamoDB tables appropriately to efficiently query nodes and edges (e.g., using GSI for edge lookups by source/target node).

## Usage / API Endpoints

Endpoints for managing the graph structure and retrieving processed outputs. (Base URL depends on API Gateway deployment).

* **`POST /nodes`**
    * **Description:** Creates a new Node (either Data Entry or Control).
    * **Request Body:**
        ```json
        {
          "projectId": "proj-abc", // ID of the graph/project
          "nodeType": "data" | "control", // Type of node
          "name": "Optional Node Name", // User-friendly name
          // --- If nodeType is 'data' ---
          "data": { // Or 'dataReference' for links like S3 URIs
            "payload": { "message": "hello world" }, // Actual data or reference
            "contentType": "application/json"
           },
          // --- If nodeType is 'control' ---
          "control": {
            "logicType": "selector | concatenator | diff | custom", // Type of logic
            "config": { // Initial configuration for the logic
              "selectionMode": "latest_by_version_edge" // Example config for a selector
            }
          },
          "metadata": { /* Optional user-defined metadata */ }
        }
        ```
    * **Response:** JSON object with the new Node's ID and details.
        ```json
        { "nodeId": "n-12345abcde", ... }
        ```

* **`GET /nodes/{nodeId}`**
    * **Description:** Retrieves details of a specific Node.
    * **Response:** JSON object with Node details.

* **`PUT /nodes/{nodeId}`**
    * **Description:** Updates an existing Node (e.g., its data, config, metadata).
    * **Request Body:** JSON object with fields to update.
    * **Response:** Updated Node details.

* **`POST /edges`**
    * **Description:** Creates a directed edge (relationship) between two nodes.
    * **Request Body:**
        ```json
        {
          "projectId": "proj-abc",
          "sourceNodeId": "n-source123",
          "targetNodeId": "n-target456",
          "edgeType": "input | version_of | processed_by | contains_label | [custom_type]", // Nature of the relationship
          "metadata": { /* Optional edge metadata, e.g., order, weight */ }
        }
        ```
    * **Response:** JSON object with the new Edge's ID.
        ```json
        { "edgeId": "e-abcdef1234" }
        ```
* **`GET /edges?sourceNodeId={id}&targetNodeId={id}&edgeType={type}`**
    * **Description:** Queries edges based on source, target, or type.
    * **Response:** Array of Edge objects.

* **`GET /outputs/{outputNodeId}`**
    * **Description:** Triggers the computation starting from the specified Control Node and returns the result. The system traverses the graph based on edge connections to gather inputs for the target `outputNodeId`.
    * **Path Parameter:** `outputNodeId` - The ID of the Control Node designated as an output.
    * **Response:** The processed output. The format depends on the `outputNodeId`'s logic type (e.g., JSON for a selector returning metadata, concatenated text/XML for a concatenator, etc.). The `Content-Type` header should reflect the output format.
        *Example (Concatenator Output):*
        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <Output node="n-output789">...</Output>
        ```
        *Example (Selector Output):*
        ```json
        // Content-Type: application/json
        { "selectedNodeId": "n-data-latest-version", ... }
        ```

*(Add/refine endpoints for deleting nodes/edges, listing nodes within a project, etc.)*

## Contributing

Contributions are welcome! Please follow standard Fork & Pull Request workflows. Ensure code is well-tested, adheres to existing style guidelines, and considers the graph-based nature of the application.

1.  Fork the repository.
2.  Create a feature branch (`git checkout -b feature/your-feature`).
3.  Commit your changes (`git commit -am 'Add feature'`).
4.  Push to the branch (`git push origin feature/your-feature`).
5.  Open a Pull Request.

## License

This project is licensed under the **MIT License**. See the [LICENSE](LICENSE) file for details.
